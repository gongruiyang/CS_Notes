## 什么是环境变量

- 定义：环境变量（environment variables）一般是指在操作系统中用来指定**操作系统运行环境**的一些**参数**

简单来说就是 系统运行环境配置的变量

## 环境变量的作用

- 设置参数：**环境变量相当于给系统或用户应用程序设置了一些参数，具体作用看用户或系统定义它的初心是干啥的**，例如要求运行一个程序时没有告诉它程序所在路径时，系统除了在当前目录中寻找该程序，还会在环境变量PATH中寻找

## 在命令行配置环境变量

> 重要的五个命令：**env echo export set unset**

### 查看环境变量---env

> 显示出当前系统中已定义的所有环境变量，其中每个环境变量以**键值对（NAME=VALUE）**的形式展示出来

```bash
[gongruiyang@localhost ~]$ env
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605259147509-ef436460-b4ab-47a9-8da4-b63aae55de52.png?x-oss-process=image%2Fresize%2Cw_1500)

> 这些变量中比较重要的是PATH环境变量，这个环境变量中存着**程序运行默认搜索路径**，后面会详细解释。

### 打印某个变量内容---echo

> echo是用来显示、打印的命令
>
> echo 字符串        ---> 原样打印字符串
>
> echo $字符串      ---> $后面字符串是一个变量名称，将**变量值**打印出来

```bash
[gongruiyang@localhost ~]$ echo PATH
PATH
[gongruiyang@localhost ~]$ MyValue=2020     <---自定义变量
[gongruiyang@localhost ~]$ echo $MyValue    <---查看自定义变量
2020
[gongruiyang@localhost ~]$ echo $PATH           <---查看环境变量
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/gongruiyang/.local/bin:/home/gongruiyang/bin:/home/gongruiyang/ClassLinunx
```

### 查看变量内容---set

> 查看所有变量内容，既可以查看环境变量，也可以查看自定义变量

```bash
[gongruiyang@localhost ~]$ MyValue=2020     <---自定义变量
[gongruiyang@localhost ~]$ echo $MyValue    <---查看变量
2020
[gongruiyang@localhost ~]$ env | grep MyValue       <---在环境变量中寻找MyValue变量，没有找到
[gongruiyang@localhost ~]$ set | grep MyValue       <---在所有变量中寻找MyValue变量，找到了并打印
MyValue=2020
```

### 声明定义转换变量---export

> 将自定义变量转换成环境变量

```bash
[gongruiyang@localhost ~]$ export MyValue               <---将自定义变量MyValue转换为环境变量
[gongruiyang@localhost ~]$ env | grep MyValue       <---在环境变量中寻找MyValue变量，找到了并打印
MyValue=2020
[gongruiyang@localhost ~]$ export MV=1999               <---声明并定义并添加环境变量MV
[gongruiyang@localhost ~]$ env | grep MV
MV=1999
```

### 删除变量---unset

> unset命令既可以删除自定义变量，也可以删除环境变量

```bash
[gongruiyang@localhost ~]$ BBBB=100
[gongruiyang@localhost ~]$ set | grep BBBB
BBBB=100
[gongruiyang@localhost ~]$ env | grep BBBB
[gongruiyang@localhost ~]$ export BBBB
[gongruiyang@localhost ~]$ set | grep BBBB
BBBB=100
[gongruiyang@localhost ~]$ env | grep BBBB
BBBB=100
[gongruiyang@localhost ~]$ unset BBBB               <---将变量BBBB删除
[gongruiyang@localhost ~]$ set | grep BBBB
[gongruiyang@localhost ~]$ env | grep BBBB
```

## 在代码中配置环境变量

### 获取环境变量

#### 方法一：getenv函数

> char *getenv(const char *name);
>
> name : 环境变量名称
>
> 返回值 ：环境变量内容的首地址

用命令行查看TESTVALUE环境变量：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605602465210-808e11ca-8f2a-4e55-902a-2b04de1c6737.png)

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
int main()
{
  //通过环境变量名称获取环境变量值                                           
  char *temp = getenv("TESTVALUE");
  if(temp == NULL)
    printf("No env var : TESTVALUE\n");
   else
    printf("TESTVALUE:[%s]\n",temp);
 
   return 0;
 }
```

运行结果如下：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605602534785-b67a9b93-7f96-421b-a711-3a3253e46aca.png)

#### 方法二：main的第三个参数

> 解释：只要运行main函数，环境变量都会被传进来，平时我们用不到环境变量，所以没去接收罢了

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int agrc,char *argv[],char *env[])
{
  int i;
  for(i=0;env[i]!=NULL;i++)
    printf("env[%d]:[%s]\n",i,env[i]);
                                           
  return 0;
}
```

输出结果：将环境变量以键值对的方式输出

```bash
[gongruiyang@localhost ClassLinunx]$ vim env.c
[gongruiyang@localhost ClassLinunx]$ make
gcc env.c -o env
[gongruiyang@localhost ClassLinunx]$ ./env 
env[0]:[XDG_SESSION_ID=3]
env[1]:[HOSTNAME=localhost.localdomain]
env[2]:[SELINUX_ROLE_REQUESTED=]
env[3]:[TERM=xterm]
env[4]:[SHELL=/bin/bash]
env[5]:[HISTSIZE=1000]
env[6]:[SSH_CLIENT=192.168.233.1 58862 22]
env[7]:[SELINUX_USE_CURRENT_RANGE=]
env[8]:[OLDPWD=/home/gongruiyang]
env[9]:[SSH_TTY=/dev/pts/0]
env[10]:[USER=gongruiyang]
env[11]:[LD_LIBRARY_PATH=:/home/gongruiyang/.VimForCpp/vim/bundle/YCM.so/el7.x86_64]
..................................................
```

#### 方法三：声明库中environ变量

> 注意哦！environ这个变量在库中是存在的，你只需要使用extern声明引入该变量就可以啦！

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int agrc,char *argv[])
{
  extern char** environ;
  
  for(int i = 0; env[i]!=NULL;i++)
    printf("environ[%d]:[%s]\n",i,environ[i]);
                                              
  return 0;                      
}                                
```

输出结果：

```bash
[gongruiyang@localhost ClassLinunx]$ ./env 
environ[0]:[XDG_SESSION_ID=3]
environ[1]:[HOSTNAME=localhost.localdomain]
environ[2]:[SELINUX_ROLE_REQUESTED=]
environ[3]:[TERM=xterm]
environ[4]:[SHELL=/bin/bash]
environ[5]:[HISTSIZE=1000]
environ[6]:[SSH_CLIENT=192.168.233.1 58862 22]
environ[7]:[SELINUX_USE_CURRENT_RANGE=]
environ[8]:[OLDPWD=/home/gongruiyang]
environ[9]:[SSH_TTY=/dev/pts/0]
environ[10]:[USER=gongruiyang]
environ[11]:[LD_LIBRARY_PATH=:/home/gongruiyang/.VimForCpp/vim/bundle/YCM.so/el7.x86_64]
.........................................
```

### 设置环境变量

#### 方法一：setenv函数

> 作用：①添加一个不存在的环境变量 ②修改一个已存在的环境变量值
>
> int setenv( const char *name ,  const char *value ,  int overwrite )
>
> - 参数列表：
>
> 1. name : 环境变量的名字
> 2. value : 环境变量的值
> 3. overwrite :  **0** 表示如果环境变量已存在不覆盖原值 ； **非0** 表示如果环境变量已存在**覆盖**原值
>
> - 返回值 : 0 表示成功 ；-1表示错误

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int agrc,char *argv[])
{

  //获取当前系统中环境变量TESTVALUE的值
  printf("Befor:[%s]\n",getenv("TESTVALUE"));

  //设置TESTVALUE的值为2020
  int ret_Modify_setenv = setenv("TESTVALUE","2020",1);
  if(!ret_Modify_setenv)
    printf("Modify success!After:[%s]\n",getenv("TESTVALUE"));
  else
    printf("Modify error!\n");

  //添加一个新的环境变量
  int ret_Add_setenv = setenv("NEWADDVALUE","2020",1);
  if(!ret_Add_setenv)
    printf("Add success!NEWADDVALUE:[%s]\n",getenv("NEWADDVALUE"));
  else
    printf("Add error!\n");                                    

  return 0;
}

```

```bash
[gongruiyang@localhost ClassLinunx]$ vim env.c
[gongruiyang@localhost ClassLinunx]$ make
gcc  env.c -o env
[gongruiyang@localhost ClassLinunx]$ ./env 
Befor:[1000]
Modify success!After:[2020]
Add success!NEWADDVALUE:[2020]
```



#### 方法二：putenv函数

> 作用：添加或修改环境变量
>
> int putenv( char *string );
>
> - 参数列表：string -> 由name=value组成
> - 返回值：0 表示 成功；非零表示

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main()
{

  char* string = "MyV=1999";                          

  int ret_putenv = putenv(string);

  //判断是否成功
  if(!ret_putenv)
    printf("put success!string:[%s]\n",getenv("MyV"));
  else
    printf("put error!\n");

  return 0;
}
```

程序运行结果：

```bash
[gongruiyang@localhost ClassLinunx]$ ./env 
put success!string:[1999]
```

### 删除环境变量

#### unsetenv函数

> 作用：
>
> int unsetenv( const char *name );
>
> - 参数列表：name -> 环境变量名称
> - 返回值 ：0 表示 删除成功；-1 表示 删除失败

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int agrc,char *argv[])
{
                                                        
  const char* name = "NEWADDVALUE";

  //获取NEWADDVALUE环境变量的值
  printf("%s=%s\n",name,getenv(name));

  //删除NEWADDVALUE环境变量
  int ret_unsetenv = unsetenv(name);
  //判断是否删除成功
  if(ret_unsetenv == 0)
    printf("delete success!%s=%s\n",name,getenv(name));
  else
    printf("delete error!\n");

  return 0;
}
```

输出结果：

```bash
[gongruiyang@localhost ClassLinunx]$ ./env 
NEWADDVALUE=2020
delete success!NEWADDVALUE=(null)
```



## 环境变量在内存中的存储位置

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605605020450-8872758b-46b5-40e5-bfb2-1beece25aa69.png)

## 关于执行文件路径的变量：$PATH

- 引例

想一想：为什么我们可以在Linux命令行模式中的任何目录中执行 ls 命令？

> ls命令的完整文件名为：/bin/ls        <---这是绝对路径
>
> 之所以我们在Linux命令行模式中的任何目录中执行 ls 都会显示出文件信息，而不会说找不到该 /bin/ls 命令，这是因为**环境变量PATH**的帮助所致



- 原理

以 ls 命令为例，当我们输入 ls 并按下回车时，系统知道你要执行一个名叫 ls 的可执行文件，这时，系统会在**PATH中定义的目录下**查找文件名为 ls 的可执行文件，如果在PATH中定义的目录中含有**多个文件名为 ls 的可执行文件**，那么找到的**第一个文件名为 ls 的文件**先执行



- 查看有哪些文件路径已被定义在PATH中

使用命令： **echo $PATH**

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605254202860-960bbeb6-78b4-4263-881e-dea5ced35c88.png)

> 上图中打印出来的是gongruiyang身份下**环境变量中定义了哪些目录**，每个目录用**冒号**（:）分开
>
> 所以可以看出gongruiyang身份下环境变量中已定义的文件目录有：
>
> /usr/local/bin
>
> **/usr/bin**
>
> /usr/local/sbin
>
> /usr/sbin
>
> /home/gongruiyang/.local/bin
>
> /home/gongruiyang/bin



> 我们来看看root身份下的环境变量中有些啥

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605254659591-7b4fe926-e28d-40ee-911c-94c1a46e5a02.png)

> 我的Linux系统中root身份和gongruiyang身份中环境变量是一样的（你的可能不一样，这很正常，环境变量中的内容是可以增减修改的，后面会详说~）



<: 这里可以更清楚的知道为啥我们在Linux命令行模式中的任何目录下都能执行 ls 了，因为无论是在root身份下还是在gongruiyang身份下的环境变量中都定义了 **user/bin** 目录，所以系统会到该目录下搜索 ls 命令，搜索到了就执行啦



**总结：环境变量是由一堆目录组成的，这些目录之间由冒号隔开，每个目录之间有先后之分**

---



- 拓展

想一想：如何让我们写的可执行程序文件，无论在哪个目录中都可以被运行呢？

> 我们写了一个输出一句话的程序

```c
#include <stdio.h>  
  
int main()  
{  
  printf("This is AKA giao, peace & love.\n"); 
                                    
  return 0;                         
}                                   
```

使用命令将其编译成可执行文件Mytest

```bash
gcc test.c -o test
```

> 我们在/home/gongruiyang/ClassLinunx目录下可以执行test可执行文件

```bash
[gongruiyang@localhost ClassLinunx]$ ls
myTest  test.c
[gongruiyang@localhost ClassLinunx]$ pwd 
/home/gongruiyang/ClassLinunx                           <----当前路径
[gongruiyang@localhost ClassLinunx]$ myTest 
This is AKA giao, peace & love.                     	<----程序输出
```

> 但是我们换一个目录，再执行就会出现下面的结果，并不能找到myTest这个可执行文件

```bash
[gongruiyang@localhost ClassLinunx]$ cd ..
[gongruiyang@localhost ~]$ myTest
bash: myTest: 没有那个文件或目录
```



为了解决无论从那个目录都能运行test可执行程序，我们需要把它所在的目录放进环境变量PATH中去



- 环境变量PATH的增加

> 目标：将/home/gongruiyang/ClassLinunx目录放入环境变量PATH中，让我们的test程序无论在哪都能执行

使用 环境变量PATH增加 命令：

```bash
PATH="${PATH}:待添加目录"
```

会有以下现象：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1693220/1605256699830-e0eed231-3420-437d-8e68-b6eb2f9c6a54.png)



这时，我们已经将包含myTest可执行文件的目录放到环境变量中，默认搜索路径就包括了ClassLinux这个文件夹，我们尝试在其他目录下运行myTest这个可执行文件就不会出现找不到文件的情况啦

```bash
[gongruiyang@localhost TestDIR]$ pwd
/home/gongruiyang/TestDIR
[gongruiyang@localhost TestDIR]$ myTest 
This is AKA giao, peace & love.
```