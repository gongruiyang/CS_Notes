# 1. TCP的三大特性

`一：面向连接`

> * 使用TCP协议通信的双方必须**先建立连接**，然后才能开始数据的读写
> * 这种**连接是一对一的**，所以基于广播和多播的程序不适用TCP协议通信
> * 双方都必须为该连接**分配必要的内核资源**，以方便管理连接的状态，方便管理连接之上数据的传输
> * 完成数据交换之后，通信双方必须**断开连接**，以**释放系统资源**

`二：可靠传输`

> * 采用**发送应答机制**，即发送端发送的每个TCP数据报都必须得到接收方的应答，才认为这个TCP报文段传输成功
> * TCP采用**超时重传机制**，即发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未接收到应答，发送端将重新发送该报文段

`三：字节流`

> * TCP模块真正开始发送数据时，发送缓冲区这些等待的**数据可能被封装成一个或多个TCP报文段**发出（解释：待发送的数据无缝排列在一起，称为一个超长字节序列，这个序列被封装成一个或多个TCP报文段发出）
> * **TCP模块发出的TCP报文段的个数** 和 **应用程序执行的写操作次数** 之间**没有固定的数量关系**（解释：程序可以等待TCP模块将报文段全部发出后，再一次性写入） 
>
> ![image-20210208144640772](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208145135.png)



# 2. TCP头部结构

![image-20210208145717829](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208145717.png)

**Linux中netinet中tcp.h中TCP报头源码**

```cpp
struct tcphdr   // TCP header.
{
    u_int16_t th_sport;     /* 源端口号 */
    u_int16_t th_dport;     /* 目的端口号 */
    u_int32_t th_seq;       /* 序号 */
    u_int32_t th_ack;       /* 确认号 */
    u_int16_t th_win;       /* 窗口 */
    u_int16_t th_sum;       /* 校验和 */
    u_int16_t th_urp;       /* 紧急指针 */

    u_int8_t th_x2:4;       /* (unused) */
    u_int8_t th_off:4;      /* data offset */
    u_int8_t th_flags;

    // URG ACK PSH RST SYN FIN
    #define TH_FIN  0x01
    #define TH_SYN  0x02
    #define TH_RST  0x04
    #define TH_PUSH 0x08
    #define TH_ACK  0x10
    #define TH_URG  0x20
};
```

## 2.1 固定头部结构（重点）

* `16位源端口号（port number）`：该报文段来自哪里
* `16位目的端口号（port number）`：该报文段去往哪里
* `32位序号（sequence number）`：一次TCP通信（从TCP连接到断开）过程中某一个传输方向上字节流的编号
* `32位确认号（acknowledgement number）`：用作对另一方发送来的TCP报文段的响应。其值是收到的报文段的**序号值+1,**。
* `4位头部长度（header length）`：标识该TCP头部有多少个4字节。因为4位最大能表示15，所以**整个TCP头部长度最大为60字节**
* `6位标志位`：
  * URG标志：表示**紧急指针是否有效**
  * ACK标志：表示**确认号是否有效**
  * PSH标志：提示接收端应用程序应该**立即从TCP接收缓冲区中中读走数据**，为接收后续数据腾出空间
  * RST标志：表示要求对方**重新建立一个连接**
  * SYN标志：表示**请求建立一个连接**
  * FIN标志：表示通知对方**本端要关闭连接**了
* `16位窗口大小（window size）`：是TCP流量控制的一种手段。这里的窗口，指的是接收通告窗口（Receiver Window，RWND）。它**告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据**，这样对方就可以控制发送数据的速度
* `16位校验和（TCP checksum）`：由**发送端填充**，接收端对TCP报文段执行**CRC算法**以检验**TCP报文段（数据+头部）**在传输过程中**是否损坏**
* `16位紧急指针（urgent pointer）`：是一个**正的偏移量**，又叫**紧急偏移**。它和序号字段相加表示最后一个紧急数据的下一个字节的序号。TCP的紧急指针**是发送端向接收端发送紧急数据的方法**

> `确认报文段`：携带**ACK**标志的TCP报文段
>
> `复位报文段`：携带**RST**标志的TCP报文段
>
> `同步报文段`：携带**SYN**标志的TCP报文段
>
> `结束报文段`：携带**FIN**标志的TCP报文段

## 2.2 可选头部结构（了解）

> 头部选项的一般结构：
>
> * `kind`：选项的类型
> * `length`：该选项的总长度
> * `info`：选项的具体信息

![image-20210208160817355](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208160817.png)

> **7种常见的TCP头部选项**

![image-20210208160857088](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208160857.png)

* kind=0是选项表结束选项。
* kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。
* kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segement Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。
* kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小时用16位表示的，故最大为65535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N乘2的M次方，或者说N左移M位。注意，M的取值范围是0~14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。
* kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。
* kind=8是时间戳选项。该选项提供了较为准确的**计算通信双方之间的回路时间**（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。

## 2.3 使用tcpdump观察TCP头部信息

![image-20210209132736343](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210209132736.png)

# 3. TCP的建立连接与释放连接

> 使用tcpdump抓取TCP建立连接与释放连接中的数据包，并用wireshark打开
>
> 客户端：Windows
>
> 服务端：虚拟机CentOS

![image-20210208173632902](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208173632.png)

## 3.1 TCP 三次握手 建立连接

`TCP三次握手时间序列图`

![image-20210208180355032](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208180355.png)

> 这里的x和y都是各自初始化产生的值
>
> **客户端向服务端**发送**第1个报文段**：报文段1包含SYN标志，因此它是一个**同步报文段**。即Windows向CentOS请求连接，将**客户端Seq值初始值x**发送过去
>
> **服务端向客户端**发送**第2个报文段**：报文段2包含SYN标志和ACK标志，因此它既是一个**同步报文段**，又是一个**确认报文段**。该报文段做两件事：①**对客户端Seq进行确认**，**确认值Ack = 客户端Seq + 1 = 1** ②给出**服务端的Seq的初始值y**。将Seq与Ack封装在报文段2中发送给客户端
>
> **客户端向服务端**发送**第3个报文段**：报文段3包含ACK标志，因此它是一个**确认报文段**。该报文段做两件事：①**对服务端Seq进行确认**，**确认值Ack = 服务端Seq + 1 = 1** ②**由于对方发送来了一个SYN报文段，消耗了本端维护的Seq中的1个值**，故本端Seq值需要加1。将Seq和Ack封装在报文段3中发送给服务端

## 3.2 TCP 四次挥手 释放连接

`TCP四次挥手时间序列`

![image-20210208181904068](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210208181904.png)

> `图中的u、v、w是之前用于数据传输后累计的值，并不是为了关闭连接而刻意初始化产生的值`
>
> **客户端向服务端**发送**第1个报文段**：报文段1包含**FIN**标志，是一个**结束报文段**。这个报文段做2件事情：①此时**客户端Seq值为u** ②将**标志位FIN设置为1**表示**客户端所有数据已经全部发送完毕，申请关闭连接**。
>
> **服务端向客户端**发送**第2个报文段**：报文段2包含**ACK**标志，是一个**确认报文段**。这个报文段做2件事情：①对客户端的关闭连接请求做出确认，确认值Ack = 客户端Seq + 1 = 2 ②此时**用于数据收发的服务端Seq值为v**，告诉客户端，如果我**下一个报文段是数据报文段而不是结束报文段**，我的**Seq值从v开始**
>
> **服务端向客户端**发送**第3个报文段**：报文段3包含**FIN**标志，是一个**结束报文段**。这个报文段做2件事情：①此时**用于关闭连接的服务端Seq值为w** ②对客户端的关闭连接请求做出确认，**确认值Ack = 客户端Seq + 1 = 2**
>
> **客户端向服务端**发送**第4个报文段**：报文段4包含**ACK**标志，是一个**确认报文段**。这个报文段做两件事：①由于对方发送来了一个**FIN标志的报文段消耗了一个序号值**，所以我需要将**我维护的Seq 加上1** ②对服务端的关闭连接请求做出确认，**确认值Ack = 服务端Seq + 1 = 2**

## 3.3 半关闭状态

* TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭
* 通信上的任何一端可以发送结束报文段给对方，告诉对方**本端已经完成了数据的发送，但可以继续接受来自对方的数据**，直到对方也发送结束报文段以关闭连接，TCP连接的这种状态称为**半关闭状态**

![image-20210209122247469](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210209122247.png)

> 服务端和客户端应用程序中**判断对方是否已经关闭连接的方法**是：read系统调用返回0（收到结束报文段）

## 3.4 连接超时

> CentOS不关闭防火墙时，Windows无法使用Telnet成功连接CentOS，在连接过程中会出现连接超时现象，连接超时后会断开连接

![image-20210209124422177](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210209124422.png)

由抓包可知，**CentOS对于外来的TCP连接请求的超时时间是15s**，根据观察这些TCP报文段被发送的时间间隔可以发现以下规律：

> 一共尝试连接6次
>
> 第1次连接时间点为：0s
>
> 第2次连接时间点为：0 + 2^0 = 1s
>
> 第3次连接时间点为：1 + 2^1 = 3s
>
> 第4次连接时间点为：3 + 2^2 = 7s
>
> 第5次连接时间点为：7 + 2^3 = 15s

## 3.5 TCP连接中的 状态转移

* TCP连接的任意一时刻都处于某种状态
* 下图是TCP连接从建立到关闭的整个过程中通信两端状态的变化

![image-20210209135313012](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210209135313.png)

## 3.6 TCP内核变量

```shell
[gongruiyang@localhost ~]$ cat /proc/sys/net/ipv4/tcp_retries1
3
[gongruiyang@localhost ~]$ cat /proc/sys/net/ipv4/tcp_retries2
15
[gongruiyang@localhost ~]$ cat /proc/sys/net/ipv4/tcp_syn_retries 
6
```

`/proc/sys/net/ipv4/tcp_syn_retries `
该文件表示本机向外发起TCP SYN连接超时重传的次数，不应该高于255；缺省设置：5

该值仅仅针对**外出的连接**，对于**进来的连接由tcp_retries1控制**。 

`/proc/sys/net/ipv4/tcp_retries1 `
该文件表示放弃回应一个TCP连接请求前进行重传的次数。 缺省设置：3 

`/proc/sys/net/ipv4/tcp_retries2 `
该文件表示放弃在已经建立通讯状态下的一个TCP数据包前进行重传的次数。 缺省设置：15 



# 4. TCP通信中的包序管理

```cpp
No      Source              Destination         Info
//三次握手
1       192.168.117.1       192.168.117.128     [SYN]           Seq=0 
2       192.168.117.128     192.168.117.1       [SYN, ACK]      Seq=0 Ack=1 
3       192.168.117.1       192.168.117.128     [ACK]           Seq=1 Ack=1 

// 客户端->服务端：hi
4       192.168.117.1       192.168.117.128     [PSH, ACK]      Seq=1 Ack=1  Len=2
5       192.168.117.128     192.168.117.1       [ACK]           Seq=1 Ack=3  Len=0

// 客户端->服务端：nihao
4       192.168.117.1       192.168.117.128     [PSH, ACK]      Seq=3 Ack=1  Len=5
5       192.168.117.128     192.168.117.1       [ACK]           Seq=1 Ack=8  Len=0

// 服务端->客户端：hi
6       192.168.117.128     192.168.117.1       [PSH, ACK]      Seq=1 Ack=8  Len=2
7       192.168.117.1       192.168.117.128     [ACK]           Seq=8 Ack=3  Len=0

// 服务端->客户端：hi
8       192.168.117.1       192.168.117.128     [PSH, ACK]      Seq=8 Ack=3  Len=2
9       192.168.117.128       192.168.117.1     [ACK]           Seq=3 Ack=10  Len=0

// 四次挥手
8       192.168.117.128     192.168.117.1       [FIN, ACK]      Seq=3  Ack=10 
9       192.168.117.1       192.168.117.128     [ACK]           Seq=10 Ack=4 
10      192.168.117.1       192.168.117.128     [FIN, ACK]      Seq=10 Ack=4 
11      192.168.117.128     192.168.117.1       [ACK]           Seq=4  Ack=11
```

