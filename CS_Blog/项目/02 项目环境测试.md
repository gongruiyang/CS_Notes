# 1. 测试gcc

输入以下命令，若` gcc `版本是` 7.3 及以上`表示 gcc 环境都没有问题 

```shell
[gongruiyang@localhost ~]$ gcc -v
...........................
gcc version 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC)
```

# 2. 测试 http 协议库

## 2.1 httplib 库的作用

Q：项目中用到的 httplib.h 是干啥的？有啥作用呢？

A：httplib.h 这个 http 协议库文件可以帮我们将自己的 CentOS 虚拟机变成一个 http 服务器，根据请求方法回调函数进行处理请求。

## 2.2 方法和类简介

我们先来看看项目中使用到的 httplib.h 中的方法及类

```cpp
struct Response {
    //.....
    std::string body;
	
    // 设置响应包头
    void set_header(const char *key, const char *val);
    void set_header(const char *key, const std::string &val);
    
	// 重定向
    void set_redirect(const char *url, int status = 302);
    void set_redirect(const std::string &url, int status = 302);
    
    // 设置响应体
    void set_content(const char *s, size_t n, const char *content_type);
    void set_content(const std::string &s, const char *content_type);

};
inline void Response::set_content(const char *s, size_t n,const char *content_type) {
  body.assign(s, n);
  auto rng = headers.equal_range("Content-Type");
  headers.erase(rng.first, rng.second);
  set_header("Content-Type", content_type);
}
inline void Response::set_content(const std::string &s,const char *content_type) {
  set_content(s.data(), s.size(), content_type);
}


struct Request {
    //.....   
};
// Server类
class Server {
    public:
    // Handler的是一个回调函数类型
    using Handler = std::function<void(const Request &, Response &)>;

    //  Server类构造和析构函数
    Server();
    virtual ~Server();

    // HTTP服务请求方法
    Server &Get(const char *pattern, Handler handler);
    Server &Post(const char *pattern, Handler handler);
    Server &Put(const char *pattern, Handler handler);
    Server &Patch(const char *pattern, Handler handler);
    Server &Delete(const char *pattern, Handler handler);
    Server &Options(const char *pattern, Handler handler);

    // 
    bool listen(const char *host, int port, int socket_flags = 0);
}
```

> Handler 回调函数解析

```cpp
using Handler = std::function<void(const Request &, Response &)>;
// 相当于以下的定义方法：
typedef std::function<void(const Request &, Response &)> Handler;
```

* `std::function<>`：这是一个 Lambda 表达式产生可调用对象 Handler 的方法，这个 Handler 对象保存在  std::function 对象中
* `Request`：是 http 请求的内容，是一个结构体，是输入型参数
* `Response`：是要给 浏览器 回复的内容，是一个结构体，是输出型参数
* 功能：用于对 http 请求的内容做出回复

> Get 函数解析

```cpp
Server& Get(const char* pattern, Handler handler)
```

* pattern：请求的`URL路径`
* handler：回调函数对象
* 功能：对于请求的 URL 路径调用回调函数 handler 对象，对请求内容进行响应；如果请求中的 URL 路径与代码中预定义的 patter 不相符，则不会调用 handler 对象

> listen 函数解析

```cpp
bool listen(const char* host, int port, int socket_flags = 0);
```

* host：主机IP端口号
* port：监听的端口号

> Response 类解析

* body：
* set_header：设置响应头字段
* set_content：设置响应包体
* set_redirect：重定向 URL ，将页面定向到其他页面

## 2.3 方法和类进行测试

### 2.3.1 模拟无响应 http 服务器

> 将`cpp-httplib文件夹中的httplib.h文件`放在一个之前创建好的文件夹`OJ/test`中
>
> 我们写一个`test.c`的测试文件，测试了解一下`httplib.h`这个库是干啥的

```cpp
#include <stdio.h>
#include "httplib.h"
void func(const httplib::Request& req, httplib::Response& rep)
{
  printf("recv abc\n");
}

int main()
{
  //创建httplib中的server类对象，使用该类对象，模拟创建一个http服务器
  httplib::Server svr;	// 实例化一个 Server 对象
  svr.Get("/abc", func);	// 该 http 服务器可以处理 /abc 这个URL的请求

  svr.listen("0.0.0.0",8989);	// 监听 8989 端口，任何 ip 都可以访问

  return 0;
}

```

> `Get`：请求方法，意为当客户机请求`/abc`资源时，便调用`func函数`对用户请求进行回应
>
> `func`：回调函数，用于处理用户的请求
>
> `listen`：填入`0.0.0.0`意为任何 ip 都可以访问本 http 服务器，该 http 服务器监听的是 8989 端口

`图解`

![image-20210305174842803](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210305174842.png)



### 2.3.2 模拟重定向 URL 的 http 服务器

> test.c

```cpp
#include <stdio.h>
#include "httplib.h"
void func(const httplib::Request& req, httplib::Response& resp)
{
  const char* BaiDuURL = "https://www.baidu.com/";
  resp.set_redirect(BaiDuURL);
}

int main()
{
  //创建httplib中的server类对象，使用该类对象，模拟创建一个http服务器
  httplib::Server svr;
  svr.Get("/abc", func);

  svr.listen("0.0.0.0",8989);

  return 0;
}

```

* 我们将访问该 http 服务器中 `abc`资源重新定向到了百度的index页面，相当于访问本机abc资源就是访问百度首页

`图解`

![image-20210305181507972](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210305181508.png)

### 2.3.3 模拟返回 HTML 页面的 http 服务器

> test.c

```cpp
#include <stdio.h>
#include <string.h>
#include "httplib.h"
void func(const httplib::Request& req, httplib::Response& resp)
{
  const char* html = "<html><h2>Hello! Welcome to my http server !</h2></html>";
  resp.set_content(html, strlen(html), "text/html");
}
int main()
{
  //创建httplib中的server类对象，使用该类对象，模拟创建一个http服务器
  httplib::Server svr;
  svr.Get("/abc", func);

  svr.listen("0.0.0.0",8989);

  return 0;
}
```

> 将编写好的 HTML 文件返回给用户

`图解`

![image-20210305182040722](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210305182040.png)



# 3. 测试Boost库

## 3.1 什么是Boost库

* boos t库是一个优秀的、可移植、开源的C++库，它是由C++标准委员会库工作自成员发起，它是对STL的延续和扩充，设计理念和STL比较接近，都是利用泛型让复用达到最大化，其中有些内容经常成为下一代C++标准库内容，在C++社区影响很大，是不折不扣的“准”标准库。

* 相比STL，boost更加实用。STL集中在算法部分，而boost包含了不少工具类，可以完成比较具体的工作。

## 3.2 split 方法源码

* 该项目中主要用到了Boost库中的字符串分割方法：boost::split

> split 方法源码定义

```cpp
template< typename SequenceSequenceT, typename RangeT, typename PredicateT >
inline SequenceSequenceT& split( SequenceSequenceT& Result,
#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
    RangeT&& Input,
#else
    RangeT& Input,
#endif
    PredicateT Pred,token_compress_mode_type eCompress=token_compress_off )
{
    return ::boost::algorithm::iter_split(
        Result,
        Input,
        ::boost::algorithm::token_finder( Pred, eCompress ) );         
}

```

`SequenceSequenceT Result`：用于存放分割后的若干个字符串的容器，一般选用 vector 来存放

`RangeT Input`：待切割字符串

`PredicateT Pred`：分隔符，切割字符串所根据的**字符串**

`token_compress_mode_type eCompress`：是否将将连续多个分隔符当一个，默认是 token_compress_off ，表示没有打开，需要传入 token_compress_on 才能将连续多个分隔符当一个。

> 参数 token_compress_mode_type 的填入选择的 源码定义

```cpp
namespace boost {
    namespace algorithm {

    //! Token compression mode 
    /*!
        Specifies token compression mode for the token_finder.
    */
    enum token_compress_mode_type
    {
        token_compress_on,    //!< Compress adjacent tokens
        token_compress_off  //!< Do not compress adjacent tokens
    };
    
    } // namespace algorithm

    // pull the names to the boost namespace
    using algorithm::token_compress_on;
    using algorithm::token_compress_off;

} // namespace boost
```

> 参数 PredicateT  的填入选择 is_any_of 的源码定义

```cpp
namespace boost {
    namespace algorithm {       
        //! is_any_of predicate
        /*!
            Construct the \c is_any_of predicate. The predicate holds if the input
            is included in the specified set of characters.

            \param Set A set of characters to be recognized
            \return An instance of the \c is_any_of predicate 
        */
        template<typename RangeT>
        inline detail::is_any_ofF<
        BOOST_STRING_TYPENAME range_value<RangeT>::type> 
            is_any_of( const RangeT& Set )
        {
            iterator_range<BOOST_STRING_TYPENAME range_const_iterator<RangeT>::type> lit_set(boost::as_literal(Set));
            return detail::is_any_ofF<BOOST_STRING_TYPENAME range_value<RangeT>::type>(lit_set); 
        }
    } // namespace algorithm
} // namespace boost
```

## 3.3 split 方法测试

> 根据空格切割字符串

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <boost/algorithm/string.hpp>

using namespace std;
using namespace boost;
int main()
{
	string test = "Hello! Welcome to my test_boost file!";
	vector<string> vec;
	split(vec, test, is_any_of(' '), token_compress_on);
	for (int i = 0; i < vec.size(); ++i)
	{
		cout << vec[i] << endl;
	}

	return 0;
}

```

> 输出：
>
> ```
> Hello!
> Welcome
> to
> my
> test_boost
> file!
> ```



# 4. 测试json库

## 4.1 什么是 json 库

* JavaScript Object Notation (JSON) 将结构化数据呈现为 JavaScript 数据的标准格式
* 常用于网站上资料的呈现与传输（将资料从服务端传送至客户端，方便网页显示）
* c++中有多种方法可以解析json数据，其中Jsoncpp是个跨平台的开源库，使用的比较多。
* JSON 值可以是：
  * 对象（在花括号中）
  * 数组（在方括号中）
  * 数字（整数或浮点数）
  * 字符串（在双引号中）
  * 逻辑值（true或false）
  * null

## 4.2 json数据表示

JSON对象：对象是键值对集合

```json
{ 
    “firstName”:“John” , 
    “lastName”:“Doe” 
}
```

![image-20210306214755297](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210306214755.png)

JSON对象数组：对象与对象之间使用`,`分割开

```json
{
    “employees”: 
    [
        { “firstName”:“John” , “lastName”:“Doe” },
        { “firstName”:“Anna” , “lastName”:“Smith” },
        { “firstName”:“Peter” , “lastName”:“Jones” }
    ]
}
```

![image-20210306214808469](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210306214808.png)

## 4.3 jsoncpp 使用简介

* 在`/usr/include/jsoncpp/json/`目录下定义的都是JSONCPP的头文件

> JSONCPP方法测试：testjsoncpp.cpp

```cpp
#include <iostream>
#include <jsoncpp/json/json.h>
using namespace std;
using namespace Json;

int main()
{
    Value v_json;
    v_json["Name"] = "Mike";
    v_json["Sex"] = "man";
    v_json["Age"] = 18;
    v_json["Weight"] = 64.7;
    v_json["Height"] = 188;                     
    // 输出json对象数组
    cout << v_json << endl;

    // 输出json对象
    cout << v_json["Name"].asString() << endl;
    cout << v_json["Sex"].asString() << endl;
    cout << v_json["Age"].asString() << endl;
    cout << v_json["Weight"].asString() << endl;
    cout << v_json["Height"].asString() << endl;

    return 0;
}
```

> 编译指令：需要加上jsoncpp**头文件**的地址`-I /usr/include/jsoncpp` 和**动态链接库**的地址`-ljsoncpp`

```shell
[gongruiyang@localhost ~]$ g++ testjsoncpp.cpp -o test -I /usr/include/jsoncpp  -ljsoncpp
[gongruiyang@localhost ~]$ ./test 
{
	"Age" : 18,
	"Height" : 188,
	"Name" : "Mike",
	"Sex" : "man",
	"Weight" : 64.700000000000003
}
Mike
man
18
64.700000000000003
188
```



# 5. 测试谷歌ctemplate库

## 5.1 什么是谷歌ctemplate库

* ctemplate (Google-ctemplate)的设计哲学是轻量级，快速，且逻辑和界面分离。
* Ctemplate就没有模板函数，没有条件判断和循环语句。
* ctemplate大体上分为两个部分，一部分是模板，另一部分是数据字典。
* 模板定义了界面展现的形式（V），数据字典就是填充模板的数据（M），你自己写业务逻辑去控制界面展现（C），典型的`MVC模型`。
* ctemplate模板中有四中标记，对应的数据字典也有不同的处理方式：
  * 变量，{{变量名}}，用两个大括号包含的就是变量名，在c++代码中，可以对变量赋值，任何类型的值都可以（如字符，整数，日期等）。
  * 片断，{{#片断名}}，片断在数据字典中表现为一个子字典，字典是可以分级的，根字典下面有多级子字典。片断可以处理条件判断和循环。
  * 包含，{{>模板名}}包含指的是一个模板可以包含其他模板，对应的也是一个字字典。
  * 注释，{{!注释名}}，包含注释。

## 5.2 ctemplate库方法测试

`TemplateDictionary类`

```cpp
explicit TemplateDictionary(const TemplateString& name, UnsafeArena* arena=NULL);
```

* 该函数是一个 TemplateDictionary 类构造方法，用于构造 TemplateDictionary  类对象
* name：无任何含义，用于调试的，可以任意指定
* arena：采用默认取NULL

```cpp
static Template *GetTemplate(const TemplateString& filename, Strip strip);
```

* filename：传入预定义的HTML文件路径
* strip：传入宏定义

| Strip宏定义       | 含义                                             |
| ----------------- | ------------------------------------------------ |
| DO_NOT_STRIP      | 不做任何修改，照原样放入模板中                   |
| STRIP_BLANK_LINES | 删除所有空行，再放入模板中                       |
| STRIP_WHITESPACE  | 删除所有空行，删除每行收尾空白字符，再放入模板中 |

## 5.3 使用ctemplate库方法填充预定义HTML模板

### 5.3.1 预定义HTML模板

> 预定义的HTML文件：all_questions.html

```html
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
    </head>
    <body>
        {{#question}}
        <div>
            <a href="/question/{{id}}">{{id}}.{{title}}({{star}})</a>
        </div>
        {{/question}}
    </body>
</html>
```

**标记写法：{{变量}}**

`{{id}}.{{title}}({{star}}`：预定义变量

`{{#question}}`：片段标记起始

`{{/question}}`：片段标记结尾

以上的变量都是需要在C++代码中进行替换的，替换成有意义的值后显示在HTML网页中

### 5.3.2 填充方法部分代码

```cpp
//一道试题需要哪些属性来描述？
struct Question
{
    std::string id_;    // 题目ID
    std::string title_;//题目名称
    std::string star_;//题目的难易程度
    std::string path_;//题目的路径

    std::string desc_;  //题目的描述
    std::string header_cpp_; //题目预定义的头
    std::string tail_cpp_; //题目的尾，包含测试用例以及调用逻辑
};

/* DrawAllQuestions：渲染 试题列表 至响应页面上 */
static void DrawAllQuestions(std::vector<struct Question>& questions, std::string* html)
{
    // 1.创建template字典
    ctemplate::TemplateDictionary dict("all_questions");
    // 2.遍历vector，每一个试题构造成一个字典
    for(auto& ques : questions)
    {
        ctemplate::TemplateDictionary* sub_dict = dict.AddSectionDictionary("question");
        sub_dict->SetValue("id", ques.id_);
        sub_dict->SetValue("id",ques.id_);
        sub_dict->SetValue("title",ques.title_);
        sub_dict->SetValue("star",ques.star_);
    }
    // 3.获取预定义html文件
    ctemplate::Template* tl = ctemplate::Template::GetTemplate("./template/all_questions.html", ctemplate::DO_NOT_STRIP);
    // 4.填充html模板
    tl->Expand(html, &dict);
}
```



### 5.3.3 填充后效果图解

![image-20210306131951249](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210306131951.png)