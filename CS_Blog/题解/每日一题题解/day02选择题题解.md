# 1

有以下定义：

```cpp
int a[10]; 
char b[80];
```

函数声明为：

```cpp
void sss(char[], int[]);
```

则正确的**函数调用**形式是（）。

A sss(a, b); 
B sss(char b[], int a[]); 
C sss(b[], a[]); 
D sss(b, a);

> 正确答案：D
>
> a是int型数组，应该传入函数的第二个参数，综上所述选择D

# 2

数组a的定义语句为“float a[3][4]; ”, 下列（）是对数组元素**不正确**的引用方法。 
A a[i][j] 
B *(a[i] + j) 
C *(*(a + i) + j) 
D *(a + i * 4 + j)

> 正确答案：D
>
> a[i] 与  \*(a+i)等价
>
> a[i][j\] 与 \*(\*(a+i)+j)等价
>
> D选项只有一层解引用，无法访问到数组元素

# 3

下面叙述**错误**的是（）

```cpp
char acX[] = ”abc”; 
char acY[] = { ‘a’, ’b’, ’c’ }; 
char *szX = ”abc”;
char *szY = ”abc”;
```

A acX 与 acY 的内容可以修改 
B szX 与 szY 指向同一个地址 
C acX 占用的内存空间比 acY 占用的大 
D szX 的内容修改后，szY 的内容也会被更改

> 正确答案：D
>
> A：正确，acX与acY都是字符数组，其中数据可以修改
>
> B：正确，szX与szY都是常量字符串，指向同一个常量字符串
>
> C：正确，acX比acY多一个'\0'，故多一个字节
>
> D：错误，szX内容修改后只是指向了其他的字符串常量而已，并不会修改szY的指向



# 4

下列代码的运行结果是（）

```cpp
int a[] = { 1, 2, 3, 4 };
int *b = a;	//b指向a数组的起始地址
*b += 2;	//相当于a[0]+=2,此时a[0]=3
*(b + 2) = 2;	//相当于赋值语句a[2]=2
b++;	//此时b指向a数组的第2个元素
printf("%d, %d \n", *b, *(b + 2));	//*b -> a[1]  *(b+2) -> a[3]
```

A 1, 3 
B 1, 2 
C 2, 4 
D 3, 2

> 正确答案：C

# 5

在**32位cpu**上**选择缺省对齐**的情况下，有如下结构体定义：

```cpp
struct A
{ 
	unsigned a : 19; 
	unsigned b : 11; 
	unsigned c : 4; 
	unsigned d : 29; 
	char index; 
};
```

则**sizeof（struct A）**的值为（）

A 9 
B 12 
C 16 
D 20

> 正确答案：C
>
> 抓住题意：**32位机器，所以默认以4字节来开辟空间**
>
> ![image-20210206102331088](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210206102338.png)



# 6

以下关于C++的描述中哪一个是**正确**的： 
A 任何指针都必须指向一个实例 
B 子类指针不可以指向父类实例 
C 任何引用都必须指向一个实例 
D 引用所指向的实例不可能无效

> 正确答案：C
>
> A：错误，指针可以是空指针
>
> B：错误，通过**强转**父类实例地址，可以让子类指针指向
>
> C：正确，引用不可以是空引用
>
> D：错误，引用不可以是空引用

# 7

以下**不是**double compare(int, int)的**重载函数**的是()

```cpp
A int    compare(double, double)
B double compare(double, double) 
C double compare(double, int) 
D int    compare(int, int)
```

> 正确答案：D
>
> 函数重载条件：①参数数据类型不同 ②参数个数不同 ③函数名相同
>
> 其中③必须满足，①和②中可以满足其中一个或多个，都可以构成函数重载
>
> 仅仅返回值不同，无法构成函数重载

# 8

关于虚函数的描述**正确**的是() 
A 派生类的虚函数与基类的虚函数具有不同的参数个数和类型 
B 内联函数不能是虚函数 
C 派生类必须重新定义基类的虚函数 
D 虚函数可以是一个static型的函数

>  正确答案：B
>
> A：错误，子类可以从父类继承过来虚函数，也可以在子类中定义属于自己的虚函数
>
> B：正确：内联函数可以是虚函数
>
> C：错误，子类需要实现父类的虚函数，而不是重新定义
>
> D：错误，仅非静态成员函数可以是虚函数

# 9

请将下列构造函数补充完整，使得程序的运行结果是5

```cpp
#include<iostream> 
using namespace std; 
class Sample
{ 
public: 
	Sample(int x)
	{ 
		________ 
	}
	~Sample()
	{ 
		if(p)
			delete p; 
	}
	int show()
	{ 
		return *p; 
	}
private: 
	int*p; 
};
int main()
{ 
	Sample S(5); 
	cout<<S.show()<<endl; 
	return 0; 
}
```

A *p = x; 
B p = new int(x); 
C *p = new int(x); 
D p = &x;

> 正确答案：B
>
> 即需要给成语变量申请空间也需要将空间内的值初始化为5
>
> A：错误，未申请空间
>
> B：正确，申请空间并初始化为5
>
> C：错误，new返回值为地址，不能用*p来接收，应该用p接收
>
> D：错误，未申请空间

# 10

关于c++的inline关键字, 以下说法**正确**的是() 
A 使用inline关键字的函数会被编译器在调用处展开 
B 头文件中可以包含inline函数的声明 
C 可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数 
D 定义在Class声明内的成员函数默认是inline函数 
E 优先使用Class声明内定义的inline函数 
F 优先使用Class实现的内inline函数的实现

> 正确答案：D
>
> A：错误，编译器可能会**不将内联函数展开**，原因可能是函数体太大,比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.
>
> B：错误，**头文件**中必须同时含有**内联函数的声明和定义**
>
> C：错误，**多个源文件**中**同名的内联函**数的**实现必须相同**
>
> D：正确，**类中定义的成员函数默认都是内联函数**
>
> E：错误，类中**定义的成员函数**都是内联函数，加不加inline都一样，没有优先一说
>
> F：错误，类中**定义的成员函数**都是内联函数，加不加inline都一样，没有优先一说

`注意：类中定义的成员函数都是内联函数，类中声明的成员函数不是内联函数`