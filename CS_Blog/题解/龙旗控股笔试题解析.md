



# 龙旗控股笔试题



## 简答题

1.Windows NT下的32位机运行环境下：

```c
char str[] = “Welcome to Bit”;
int Array[] = {1,2,3,4,5,6,7,8,9};
char *p = str;
int  n;
int func( int a[] ) {}
请计算：strlen(str), sizeof(str), sizeof(Array), sizeof(p), sizeof(n), sizeof(a)
```

> strlen(str) = 14  解析：strlen函数计算字符串长度时，以'\0'为结束标志，所以‘\0’前面有14个字符，其长度便是14
>
> sizeof(str) = 15 解析：sizeof运算符是求该变量所占内存大小，由于'\0'也是一个字符，占一个字符的内存，所以该字符串所占内存大小需要加上'\0'的大小，其大小为 15 字节
>
> ![image-20200912153714221](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912153714221.png)
>
> sizeof(Array) = 9 * 4 = 36 解析：Array是一个整形数组，存储了9个整形变量，一个整形变量占4个字节，所以共占 36 个字节
>
> ![image-20200912154317103](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912154317103.png)
>
> sizeof(p) = 4 解析：所有的指针类型都占 4 个字节
>
> sizeof(n) = 4 解析：整形变量占 4 字节
>
> sizeof(a) = 4 解析：数组作为形参传入函数，需要将维成 指针 ，传入函数中的是 数组首元素的地址，指针类型都是占 4 字节，所以其大小为 4 字节

------



2、请观察下列程序运行时是否会出现问题，若有，请指出问题，若不存在问题，请指出程序循环的次数

```c
#define MAX_SIZE 255
void main()
{
    unsigned char buff[MAX_SIZE +1];
    unsigned char i;
    for(i=0; i <= MAX_SIZE; i++)
    {
    	buff[i] = i;
    }
}
```

> 程序问题：死循环
>
> 原因解析：由于 unsigned char 数据类型，其取值范围为 [0,255] ，所以 i <= 255恒成立，循环继续条件恒成立，导致死循环

------



3、添加下面粗体部分代码的初衷是为了给gui_show_image这句代码的执行加上限制条件，请问这样修改有没有什么隐患，若有，该如何修改？

```c
...................
gui_push_clip();

#ifdef AAA
		if (show_status == MMI_TRUE)
#endif
            
#ifdef BBB
		gui_show_image(x , y , image_id);
#endif

		gui_pop_clip();
		update_dt_display();
....................
```

> AAA和BBB同时定义或同时不定义的情况下，该代码没有问题
>
> 当AAA和BBB有一个没有定义的情况下，该代码有问题
>
> 1.当只定义AAA情况下：
>
> ![image-20200912172213546](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912172213546.png)
>
> 2.当只定义BBB情况下：
>
> ![image-20200912172319419](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912172319419.png)
>
> 有悖于题目中要求用AAA来限制BBB中代码的是否执行

修改建议：

**方法一：**

![image-20200912172721357](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912172721357.png)

方法二：

![image-20200912172818724](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912172818724.png)

---

4、请问下面程序运行后会出现什么问题，该如何修改，另外，从培养良好的编程规范角度看，哪些地方需要修改？

```c
void GetMemory(char *p)
{
	p = (char*)malloc(57);
}
void main()
{
	char *str = NULL;
	GetMemory(str);
	strcpy(str, "51 C++");
	printf(str);
}
```

> 问题：该函数无法给str开辟空间，str依旧指向NULL
>
> 原因解析：p是str的形参，函数给p开辟了空间，并不是给str开辟空间，当函数执行完毕，临时变量p被销毁，开辟的空间也就不可用了
>
> ![image-20200912160426582](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912160426582.png)
>
> ![image-20200912160548055](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20200912160548055.png)
>
> 解决方案：传入str的地址，形参使用二级指针，可将函数中开辟的空间带出去



```c
char * GetMemory(void)
{
	char p[] = "51 C++";
	return p;
}
void main()
{
	char *str = NULL;
	str = GetMemory();
	printf(str);
}
```

> 问题：函数执行结束后，临时变量p被销毁，导致p空间中的数据无效，所以在main函数中的str虽然指向了p的空间，但是无法访问无效数据，最终输出的是乱码



```c
void GetMemory(char **p)
{
	*p = (char *)malloc(57);
}
void main()
{
	char *str = NULL;
	GetMemory(&str);
	strcpy(str, "51 C++");
	printf(str);
}
```

> 没有错误，但是好的编程习惯要求，使用malloc开辟的空间需要free，不释放空间会导致内存泄漏
>
> 修改方法：
>
> ```c
> void GetMemory(char **p)
> {
> 	*p = (char *)malloc(57);
> }
> void main()
> {
> 	char *str = NULL;
> 	GetMemory(&str);
> 	strcpy(str, "51 C++");
> 	printf(str);
>     
>     free(str);
>     str = NULL;
> }
> ```





```c
void main()
{
	char *str = (char *)malloc(57);
	strcpy(str, "51CC");
	free(str);
    
	if (str != NULL)
	{
		strcpy(str, "C++");
		printf(str);
	}
}
```

> 问题：将str内存释放之后，并未将str置为NULL，导致str成为 野指针 ，指向了 非法内存 ，str != NULL成立，导致向非法内存中拷贝数据，造成了非法内存访问
>
> 修改建议：
>
> ```c
> void main()
> {
> 	char *str = (char *)malloc(57);
> 	strcpy(str, "51CC");
> 	free(str);
>     
>     str = NULL;
>     
> 	if (str != NULL)
> 	{
> 		strcpy(str, "C++");
> 		printf(str);
> 	}
> }
> ```



---

## 编程题

```c
1、请编码实现以下功能的函数
功能：实现对一个8 bit数据（unsigned char类型）的指定位（例如第n位）的置0或者置1操作，并保持其他位不变。
函数原型：
void bit_set(unsigned char *p_data, unsigned char position, bool flag)
函数参数说明：
P_data 是指定的源数据，position是指定位（取值范围1~8）；flag表示是置0还是置1操作，true: 置1  flase:置0
```

方法一：

```c
void bit_set(unsigned char* p_data, unsigned char position, bool flag){
	//寻找操作位置
	unsigned char i = 1;
	i <<= (position-1);
	if (flag){	
		//设置为1
		*p_data |= i;
		return;
	}
	//设置为0
	unsigned char k = 255;
	k -= i;
	*p_data &= k;
}
```

方法二：

```c
void bit_set(unsigned char *p_data, unsigned char position, bool flag)
{
	if (flag)
		*p_data |= (0x01 << (position - 1));
	else
		*p_data &= ~(0x01 << (position - 1));
}
```

---

```
2、请实现字符串右循环移位函数，比如：“abcdefghi”循环右移2位就是“hiabcdefg”.
函数原型：void RightLoopMove(char *pStr, unsigned short steps)
函数参数说明：
pStr: Point to a ‘\0’ terminated string
steps: The rotate shift numbers
```

方法一：

```c
void RightLoopMove(char *pStr, unsigned short steps)
{
	assert(pStr != NULL && *pStr!='\0');
	int len = strlen(pStr);
	char *tmp = (char*)malloc(sizeof(char) * (len+1)); //空间复杂度O(n)
	assert(tmp != NULL);

	steps %= len;  //

	strcpy(tmp, pStr+(len-steps));
	strncat(tmp, pStr, len-steps);

	strncpy(pStr, tmp, len);
	free(tmp);
	tmp = NULL;
}
```

方法二：

```c
void RightLoopMove(char *pStr, unsigned short steps)
{
	assert(pStr != NULL && *pStr!='\0');
	int len = strlen(pStr);
	steps %= len;
	for(int i=0; i<steps; ++i)
	{
		char tmp = pStr[len-1];              //空间复杂度O(1)
		for(int end=len-1; end>0; --end)     //时间复杂度O(n^2)
			pStr[end] = pStr[end-1];
		pStr[0] = tmp;
	}
}
```













