# 牛客题解

## 名企高频面试题

### 1.判断列表中是否有环

链接：[判断列表中是否有环](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&&tqId=36313&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

#### 解法一：快慢指针法

- 思路：

1. 一个慢指针slow和一个快指针fast指向头结点head
2. 循环移动slow和fast，slow和fast移动步长分别为1和2
3. 移动过程中：如果fast为NULL则代表没有环；如果fast==slow则代表有环



- 时间复杂度：O(N)
- 空间复杂度：O(1)



- 实现代码

```
    bool hasCycle(ListNode *head) {
        if(!head || !head->next) return false;
        
        ListNode *slow = head, *fast = head;
        while(fast && fast->next )
        {
            slow = slow->next;
            fast = fast->next->next;
            if(fast == slow) return true;
        }
        return false;
    }
```



#### 解法二：查表法

- 思路：

1. 创建一个vector用于存放结点地址，创建一个结点指针p用于遍历链表
2. 一边遍历链表一边将结点放入vector中，遍历过程中：如果出现p为NULL则代表没有环，如果vector中已经保存过了则代表有环



- 时间复杂度：O(N)
- 空间复杂度：O(N)



- 实现代码

```
bool isContainNode(ListNode* p,vector<ListNode*>& v)
{
    for(auto i = v.begin(); i != v.end(); i++)
    {
        if((*i) == p) return true;    //包含p
    }
    return false;    //没有p
} 
bool hasCycle(ListNode *head) {
    if(!head || !head->next) return false;

    vector<ListNode*> listNodes;
    ListNode* p = head->next;
    listNodes.push_back(head);
    //如果vector中包含p说明有环
    while(!isContainNode(p,listNodes))    //p不为空 且 vector中没有该结点
    {
        if(p == nullptr || p->next == nullptr) return false;
        else listNodes.push_back(p);
        p = p->next;
    }
    return true;
}
```

### 2.反转链表

链接：[反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&&tqId=36521&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

#### 解法一：三指针法

- 思路

> 三个指针：s/p/q
>
> s指向头结点
>
> p指向正在反转的结点
>
> q指向剩余未反转的结点的第一个结点
>
> pqs三指针迭代将链表进行反转
>
> ![image.png](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210303122054.png)



- 时间复杂度：O( N )
- 空间复杂度：O( 1 )



- 代码

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr) return pHead;
        ListNode *s=pHead->next,*p=s,*q=s;
        pHead->next = nullptr;
        s = pHead;
        while(q != nullptr)
        {
            q = q->next;
            p->next = s;
            s = p;
            pHead = s;
            p = q;
        }
        return pHead;
    }
};
```





### 3.删除链表的倒数第n个结点

链接：[删除链表的倒数第n个结点](https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=188&&tqId=36538&rp=1&ru=/ta/job-code-high-week&qru=/ta/job-code-high-week/question-ranking)

#### 解法一：转化法

- 思路

> 1. 求出链表长度
> 2. 处理特殊结点
> 3. 将倒数第 n 个结点处理成正数第 k 个结点，找到 k 与 n 的关系
> 4. 删除该结点



- 时间复杂度：O( N )
- 空间复杂度：O( 1 )



- 代码：

```
/**
 * struct ListNode {
 *  int val;
 *  struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // write code here
        // 求链表长度length
        int length = 0;
        ListNode* cur_node = head;
        while(cur_node)
        {
            cur_node = cur_node->next;
            length++;
        }
        //处理链表长度为0或删除的节点为第一个
        if(length == 0 || length < n) return head;
        if(length == n) return head->next;
        //处理删除第一个之后的节点，
        //befor_cur_node    待删除节点的前一个节点
        //cur_node    待删除结点
        //after_cur_node    待删除结点的后一个结点
        //step    表示befor_cur_node需要前进多少步寻找到待删节点的直接前继
        int step = length-n-1;
        ListNode* befor_cur_node = head;
        while(step)
        {
            befor_cur_node = befor_cur_node->next;
            step--;
        }
        cur_node = befor_cur_node->next;
        ListNode* after_cur_node = cur_node->next;
        befor_cur_node->next = after_cur_node;
        free(cur_node);
        cur_node = NULL;
        return head;
    }
};
```

### 5.链表中环的入口节点

链接：[链表中环的入口节点](https://www.nowcoder.com/practice/6e630519bf86480296d0f1c868d425ad?tpId=117&&tqId=34924&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

#### 解法一：查表法

- 思路

> 将结点放入vector中，检查当前结点是否在vector中存在过，如果存在则代表该结点为环入口，如果不存在则放入



- 时间复杂度：O( N )
- 空间复杂度：O( N )



- 代码

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        //空链表
        if(head == NULL || head->next == NULL) return NULL;
        //用于存放
        vector<ListNode*> ms;
        ListNode* cur_node = head->next;
        
        ms.push_back(head);
        
        while(cur_node != NULL && !isContain(cur_node,ms))
        {
            ms.push_back(cur_node);
            cur_node = cur_node->next;
        }
        return cur_node;
    }
private:
    bool isContain(ListNode *cur_node,vector<ListNode*> ms)
    {
        for(auto i = ms.begin(); i != ms.end(); i++)
            if(*i == cur_node) return true;
        return false;
    }
};
```

### 6.两个链表的第一个公共结点

链接：[两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=117&&tqId=34988&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

#### 解法一：查表法

- 思路

> 1. 将一个链表的所有节点放入一个容器中
> 2. 遍历第二个链表检查节点是否存在容器中



- 时间复杂度：O( N )
- 空间复杂度：O( N )





- 代码

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        vector<ListNode*> v;
        ListNode* cur_node = pHead1;
        while(cur_node != NULL)
        {
            v.push_back(cur_node);
            cur_node = cur_node->next;
        }
        cur_node = pHead2;
        while(cur_node != NULL)
        {
            if(isContain(cur_node,v)) return cur_node;
            cur_node = cur_node->next;
        }
        return NULL;
    }
private:
    bool isContain(ListNode* cur_node , vector<ListNode*> v)
    {
        for(auto i = v.begin();i != v.end();i++)
            if(*i == cur_node) return true;
        return false;
    }
    
};
```



### 7.求二叉树的层序遍历

#### 解法一：使用队列实现BFS

- 思路

> 层序遍历时用一个cur_level_size记录当前层节点个数



- 时间复杂度：O( N )
- 空间复杂度：O( N )



- 代码

```
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型vector<vector<>>
     */
    vector<vector<int> > levelOrder(TreeNode* root) {
        // write code here
        vector<vector<int>> vv;
        if(root == nullptr) return vv;
        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty())
        {
            vector<int> v;
            int cur_level_size = q.size();
            while(cur_level_size--)
            {
                TreeNode* cur_Node = q.front();
                q.pop();
                v.push_back(cur_Node->val);
                if(cur_Node->left) q.push(cur_Node->left);
                if(cur_Node->right) q.push(cur_Node->right);
            }
            if(v.size()>0) vv.push_back(v);
        }
        return vv;
    }
};
```

### 8.子数组的最大累加和问题

链接：[子数组的最大累加和问题](https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=191&&tqId=36298&rp=1&ru=/activity/oj&qru=/ta/job-code-high-algorithm/question-ranking)

#### 解法一：贪心法

- 思路：

> 



- 时间复杂度：
- 空间复杂度：



- 代码

```
class Solution {
public:
    /**
     * max sum of the subarray
     * @param arr int整型vector the array
     * @return int整型
     */
    int maxsumofSubarray(vector<int>& arr) {
        // write code here
        int result = INT32_MIN;
        int count = 0;
        for(int i = 0; i < arr.size(); i++)
        {
            count += arr[i];
            if(count > result) result = count; //保存从最初以来的最大值
            if(count <= 0) count = 0;   
        }
        return result;
    }
};
```

#### 解法二：前缀和数组

#### 解法三：暴力法



### 9.不要二

链接：



#### 解法一：找规律法

```
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int W, H, i, j, counts = 0;
    cin >> W >> H;
    if (W % 4 == 0 || H % 4 == 0)  //行能整除4 或 列能整除4
        counts = W * H / 2;
    else if (W % 2 == 0 && H % 2 == 0)  //行和列 都是偶数的情况
        counts = (W * H / 4 + 1) * 2;
    else  //其他情况
        counts = W * H / 2 + 1;
    cout << counts << endl;
    return 0;
}
```

### 10.数组中相加和为0的三元组

链接：[数组中相加和为0的三元组](https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=191&&tqId=36130&rp=1&ru=/ta/job-code-high-algorithm&qru=/ta/job-code-high-algorithm/question-ranking)

#### 解法一：双指针

- 思路：

> 先将数组排序，然后定下来一个数字，使用首尾指针寻找另外两个数字
>
> 注意：
>
> 1. 定下来的第一个数字大于0就没有找下去的必要了
> 2. 部分解插入后要去重，并清空部分解集合
> 3. for循环一次后要对第一个数字去重

- 时间复杂度：O( NlogN )
- 空间复杂度：O(1)



- 代码

```
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        
        vector<vector<int>> ans;    //用于存储最终答案集合
        vector<int> solve;      //用于存储部分解
        
        //特殊情况判定
        if(num.size() < 3) return ans;
        
        //从小到大排序
        sort(num.begin(),num.end());
        
        //定下来一个数 转化 为求另外两个数的和，定下来的这个数必须小于等于0，大于0就没必要找下去了
        for(int i = 0; i < num.size() - 2 && num[i] <= 0 ;)
        {
            //首尾指针
            int begin = i + 1;
            int end = num.size()-1;
            
            //寻找另外两个元素
            while(begin < end)
            {
                int sum = num[i]+num[begin]+num[end];
                if(sum > 0)  end--;
                else if(sum < 0) begin++;
                else
                {
                    //更新答案容器
                    solve.push_back(num[i]);
                    solve.push_back(num[begin]);
                    solve.push_back(num[end]);
                    ans.push_back(solve);
                    solve.clear();
                    
                    //另外两个元素去重
                    while(begin+1<end && num[begin] == num[begin+1]) begin++;
                    while(begin<end-1 && num[end] == num[end-1]) end--;
                    begin++,end--;
                }
            }
            
            //首元素去重
            while(i+1<num.size()-2 && num[i] == num[i+1]) i++;
            i++;
        }
        return ans;
    }
};
```



### 11.两个链表生成相加链表

链接：[两个链表生成相加链表](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=117&&tqId=35073&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

#### 解法一：两次逆置链表法

- 思路

> 1. 将两个链表逆置后进行相加，再将和保存在长链表中
> 2. 再将两个链表反转
> 3. 将长链表返回



- 时间复杂度：O( N )
- 空间复杂度：O( 1 )



- 代码

```
class Solution {
public:
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        // write code here
        //求出两个链表长度
        int lena = length(head1);
        int lenb = length(head2);
        //特殊情况判断
        if(lena == 0) return head2;
        if(lenb == 0) return head1;
        //逆置两个链表
        head1 = ReverseList(head1);
        head2 = ReverseList(head2);
        //len用于存储两个两链表中最短的那个长度
        int len = lena>lenb?lenb:lena;
        //定义两个指针分别指向长短链表
        ListNode* L,*S;
        if(len == lena)
        {
            L = head2;
            S = head1;
        }else{
            L = head1;
            S = head2;
        }
        //用于存储一位上的和
        int temp = 0;
        //存放最短链表长度
        int count = len;
        //总体求和
        while(count)
        {
            temp = L->val + S->val;
            L->val = temp % 10;
            if(temp>9)
            {
                if(L->next!=NULL)
                    L->next->val +=1;
                else{
                    //如果两链表长度相等 且 最后一位需要进位
                    ListNode* add = new ListNode(1);
                    L->next = add;
                    add->next = NULL;
                }
            }
            L=L->next;
            S=S->next;
            count--;
        }
        //求和的最后一位如果是大于9的情况处理
        while(L != NULL && L->val>9)
        {
            if(L->next != NULL)
                L->next->val += 1;
            else
            {
                ListNode* add = new ListNode(1);
                L->next = add;
                add->next = NULL;
            }
            L->val = L->val - 10;
            L = L->next;
        }
        //求完和后逆置链表
        head1 = ReverseList(head1);
        head2 = ReverseList(head2);
        
        //判断那链表头结点需要输出
        if(lena == lenb)
            return head2;
        else{
            if(lena == len) return head2;
            return head1;
        }
    }
private:
    int length(ListNode* p)
    {
        int len = 0;
        while(p!=NULL)
        {
            p=p->next;
            len++;
        }
        return len;
    }
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr) return pHead;
        ListNode *s=pHead->next,*p=s,*q=s;
        pHead->next = nullptr;
        s = pHead;
        while(q != nullptr)
        {
            q = q->next;
            p->next = s;
            s = p;
            pHead = s;
            p = q;
        }
        return pHead;
    }
};
```

### 12.链表内指定区间反转

链接：[链表内指定区间反转](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=190&&tqId=35184&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

#### 解法一：四指针定位法

- 思路

> 四个指针分别定位



- 时间复杂度：O( N )
- 空间复杂度：O( 1 )



- 代码

```
/**
 * struct ListNode {
 *  int val;
 *  struct ListNode *next;
 * };
 */
class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        //边界条件判断
        ListNode* p = head;
        int len = ListLength(p);    //长度
        int beforNum = m-1;        //第m个结点的前一个节点下标
        int afterNum = n+1;        //第n个结点的下一个节点下标
        
        //边界条件判断
        if(len < m || m > n || m == n) return head;
        if(beforNum < 0 || afterNum > len+1) return head;
        
        //定位befor指向第m个结点的前一个节点，定位after指向第n个结点的后一个结点
        ListNode* befor = head;
        ListNode* after = head;
        if(beforNum == 0) //恰好第m个结点为头结点
            befor = head;
        else
        {
            while(beforNum>1)
            {
                befor = befor->next;
                beforNum--;
            }
        }
        if(afterNum == len+1) //恰好第n个结点为尾节点
            after = NULL;
        else
        {
            while(afterNum>1)
            {
                after = after->next;
                afterNum--;
            }
        }
        
        //定位第n个结点和第m个结点
        ListNode* NodeM  = head;
        if(befor == head && beforNum == 0)
            NodeM = head;
        else
            NodeM = befor->next;
        ListNode* NodeN = head;

        while(NodeN->next != after) NodeN = NodeN->next;
        
        //将待反转链表取出
        if(befor == head && beforNum == 0)
            head = befor = NULL;
        else
            befor->next = NULL;
        NodeN->next = NULL;
        
        //反转部分链表
        NodeM = ReverseList(NodeM);
        
        //反转后NodeM和NodeN结点指向同一个结点，需更新NodeN结点放到最后
        while(NodeN->next != NULL) NodeN = NodeN->next;
        
        //将待反转链表插回去
        if(head == NULL && beforNum == 0)
            head = befor = NodeM;
        else
            befor->next = NodeM;
        NodeN->next = after;
        
        return head;
    }
private:
    int ListLength(ListNode* pHead)
    {
        int ans = 0;
        while(pHead != NULL) 
        {
            pHead = pHead->next;
            ans++;
        }
            
        return ans;
    }
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr) return pHead;
        ListNode *s=pHead->next,*p=s,*q=s;
        pHead->next = nullptr;
        s = pHead;
        while(q != nullptr)
        {
            q = q->next;
            p->next = s;
            s = p;
            pHead = s;
            p = q;
        }
        return pHead;
    }
};
```

### 13.删除有序链表中重复出现的元素

链接：[删除有序链表中重复出现的元素](https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=190&&tqId=35342&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

#### 解法一：双指针

- 思路

> 两个指针相邻一起向后走，判断后面的指针指向结点的值与该结点的后继结点的值是否相等，若相等则后移至不相等的结点，进行链表截断

- 时间复杂度：O( N )
- 空间复杂度：O( 1 )



- 代码

```
/**
 * struct ListNode {
 *  int val;
 *  struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    ListNode* deleteDuplicates(ListNode* head) {
        //处理链表表头出现相同值的情况
        if(head == NULL || head->next == NULL) return head;
        while(head != NULL && head->next != NULL && head->val == head->next->val)
        {
            while(head->next != NULL && head->val == head->next->val)
                head = head->next;
            head = head->next;
        }
        if(head == NULL || head->next == NULL) return head;
        //处理链表中出现相同数值的情况
        ListNode* p = head;
        ListNode* q = head->next;
        while(q != NULL && q->next != NULL)
        {
            if(q->val == q->next->val)
            {
                while(q->next != NULL && q->val == q->next->val) q = q->next;
                if(q->next != NULL)
                    q = q->next;
                else
                    q = NULL;
                p->next = q;
            }
            else
            {
                q = q->next;
                p = p->next;
            }
        }
        return head;
    }
};
```

## 剑指Offer

### 1.二叉树中和为某一值的路径

链接：[二叉树中和为某一值的路径](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

#### 解法一：前序遍历（DFS）

- 思路

> 前序遍历：一边访问一边放入路径中，到叶节点时判断此时key值(若为0则代表是一条可选路径)，回溯时将结点pop出来



- 时间复杂度：O( N )
- 空间复杂度：O( N )



- 代码

```
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    vector<vector<int> > FindPath(TreeNode* root,int key) {
        vector<vector<int> > ans;
        vector<int> route;
        TreeNode* pt = root;
        
        if(!pt) return ans;
        
        DFS(ans,route,pt,key);
        
        return ans;
    }
private:
    void DFS(vector<vector<int>>& ans,vector<int>& route,TreeNode* node,int key)
    {
        if(!node->left && !node->right)
        {
            route.push_back(node->val);
            if(key - node->val == 0) ans.push_back(route);
            route.pop_back();
            return ;
        }
        else
        {
            route.push_back(node->val);
            if(node->left)
                DFS(ans,route,node->left,key - node->val);
            if(node->right)
                DFS(ans,route,node->right,key - node->val);
            route.pop_back();
        }
    }
};
```



### 36.二叉搜索树与双向链表

链接：[二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

#### 解法一：存储在vector中进行链接

- 思路：

> 对树进行中序遍历，将结点存储在vector容器中，然后从左向右进行链接，返回容器中第一个节点

- 时间复杂度：
- 空间复杂度：O( N )



- 代码

```
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(root == NULL) return NULL;
        vector<Node*> v;
        InorderTraversal(v,root);
        for(int i = 0; i < v.size(); i++)
        {
            if(i != v.size()-1)
                v[i]->right = v[i+1];
            else
                v[i]->right = v[0];
            if(i != 0)
                v[i]->left = v[i-1];
            else
                v[i]->left = v[v.size()-1];
        }
        return v[0];
    }
private:
    void InorderTraversal(vector<Node*>& v, Node* root)
    {
        if(root == NULL)
            return ;
        else
        {
            InorderTraversal(v,root->left);
            v.push_back(root);
            InorderTraversal(v,root->right);
        }
    }
};
```