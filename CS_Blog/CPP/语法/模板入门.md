# 1. 泛型编程

> 如何实现一个**通用的交换函数**呢？
>
> 你可能首先会想到使用**函数重载**，使用函数重载虽然可以实现，但是它有以下的缺点：
>
> 1. 重载的函数代码重复率较高，当出现新类型的时候，就需要增加对应类型的重载函数
> 2. 代码的可维护性较低，一个出错可能所有的重载均出错



* 最佳的做法还是告诉编译器一个模板。当编译器遇到**不同的数据类型**时根据该**模板**自动生成相同功能的代码
* 在C++编程思想中有一种思想叫做**泛型编程**，即编写与类型无关的通用代码，这是一种**代码复用**的手段，模板是泛型编程的基础

![image-20210128163355722](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20210128163355722.png)



# 2. 函数模板

## 2.1 函数模板概念

> 函数模板就代表了完成同一个功能的函数家族，该函数模板与数据类型无关，在使用该函数时，根据实参的数据类型产生特定数据类型的函数



## 2.2 函数模板格式

> 在函数前加上下面格式的代码：
>
> ```cpp
> template<typename T1, typename T2,......,typename Tn>
> ```



## 2.3 通用的交换函数

```cpp
template<typename T>
void Swap( T& left, T& right) {
    T temp = left;
    left = right;
    right = temp; 
}
```

> 注意：typename是用来定义模板的关键字，也可以使用class

在编译器**编译阶段**，对于模板函数的使用，编译器需要**根据传入的实参类型**来**推演生成对应类型的函数**以供调用。

比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此



## 2.4 反汇编代码验证

> 由汇编代码看出：编译器根据**数据类型**按照**模板函数**自动生成了**相应的实例化函数**

```cpp
#include <iostream>
using namespace std;

template<typename T>
T add(T a, T b)
{
    return a + b;
}

int main()
{
    add(1, 2);
    add(1.0, 2.0);
    add('1', '2');
    cout << endl;
    
    return 0;
}
```

![image-20210128170022567](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20210128170022567.png)



## 2.5 不同数据类型的函数模板

```cpp
template<typename T, class S>
void fun(T a, S b)
{
	// TO DO
}
```



## 2.6 隐式实例化与显式实例化

`隐式实例化`：让**编译器**根据**实参**`推演`**模板参数**的**实际类型**

```cpp
add(1,2);	 //隐式实例化
```

`显式实例化`：在函数名后的`<>`中**指定**模板参数的**实际类型**

```cpp
add<int>(1,2);	//显式实例化
```

## 2.7 模板参数的匹配原则

> 1. 当函数模板和类型实例化函数同时出现时，并且传参使用的是隐式实例化，编译器**首先匹配函数**而不是使用模板实例化函数

![image-20210129104342689](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20210129104342689.png)

> 2. 当函数模板和类型实例化函数同时出现时，并且传参使用的是显示实例化，编译器**首先使用模板函数**

![image-20210129104508002](C:\Users\1111\AppData\Roaming\Typora\typora-user-images\image-20210129104508002.png)

# 3. 类模板

## 3.1 类模板的定义格式

```cpp
template<class T1, class T2, class T3, ..., class Tn>
class ClassName{
    //TO DO
};
```

## 3.2 使用类模板实现动态类型顺序表

> 在实例化类时需传递数据类型

```cpp
template<class T>
class SeqList
{
private:
	T* dataArray;
	size_t capacity;
	size_t size;
public:
	//构造函数与析构函数
	SeqList(size_t capacity = 10) :capacity(capacity), dataArray(new T[capacity]), size(0){}
	SeqList(const SeqList<T>& s)
	{
		capacity = s.capacity;
		dataArray = new T(capacity);
		for (size = 0; size < s.size; size++)
			dataArray[size] = s[size];
	}
	SeqList<T>& operator=(const SeqList<T>& s)
	{
		capacity = s.capacity;
		dataArray = new T(capacity);
		for (size = 0; size < s.size; size++)
			dataArray[size] = s[size];
	}
	T& operator[](const size_t index)
	{
		if (index < size && index >= 0)
		{
			return dataArray[index];
		}
		else
		{
			return -1;
		}
	}
	~SeqList()
	{
		if (dataArray)
		{
			delete[] dataArray;
			capacity = 0;
			size = 0;
		}
	}
	//具体方法
	size_t getSize() const;
	size_t getCapacity() const;
	bool isEmpty()const;
	void push_back(const T& data);
	void pop_back();
	T front();
};
// 具体方法的类外实现
template<class T>
size_t SeqList<T>::getSize() const
{
	return size;
}
template<class T>
size_t SeqList<T>::getCapacity() const
{
	return capacity;
}
template<class T>
bool SeqList<T>::isEmpty()const
{
	return 0 == size;
}
template<class T>
void SeqList<T>::push_back(const T& data)
{
	if (size < capacity)//空间足够
	{
		dataArray[size] = data;
		size++;
	}
	else//空间不够
	{
		return;
	}
}
template<class T>
void SeqList<T>::pop_back()
{
	if (isEmpty())
	{
		return;
	}
	size--;
}
template<class T>
T SeqList<T>::front()
{
	return dataArray[size - 1];
}
```

