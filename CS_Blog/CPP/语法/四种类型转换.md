# 前言：C语言中的类型转换

C语言中的强制类型转换很简单方便，不管是什么类型转换都是使用以下方式：

```cpp
TypeA a = (TypeB) b;
```

但是这种转换方法过于松散，正是这种方便可能会导致写出许多的无意义的强转代码

```cpp
struct Data{
	double data[200];
};
struct Junk{
	int junk[100];
};

Data d = {2.4e10, 3.5e-1, 20.2e32};
char* pch = (char*)(&d);	// 转换为字符串
char ch = (char)(&d);	// 转换为字符
Junk* pj = (Junk*)(&d);	// 转换为Junk指针
```

以上的三种强制转换并无任何实际意义，但是在C语言中，这些转换都是允许的，为了应对这种松散的情况，Stroustrop采取的措施是严格的限制允许进行的类型换换，并添加4个类型转换运算符，使得转换过程更为规范：

* dynamic_cast
* const_cast
* static_cast
* reinterpret_cast

# dynamic_cast

规则：`dynamic_cast <type-name> (expression)`

功能：能够在类层次中向上转换，其他不相干的类之间无法使用该运算符转换

适用对象：存在is-a关系的对象之间的转换

```cpp
class High{};
class Low : public High{};
class Other{};

Low* pl = new Low();
Other* po = new Other();

High* ph  = dynamic_cast<High *>(pl);	// 	合法转换
High* ph = dynamic_cast<High *>(po);	//	非法转换
```



# const_cast

规则：`const_cast <type-name> (expression)`

功能：将一个常量转换为可修改的变量

适用场景：有时候可能需要这样一个值，它在大多数情况下是常量，而有时候又是可以修改的，在这种情况下，可以将这个值声明为 const，并在需要修改它的时候使用 const_cast

```cpp
High bar;
const High* pbar = &bar;

High* ph = const_cast<High*> (pbar);				// 合法转换
const Low* pl = const_cast<const Low*> (pbar);		// 非法转换
```

第一种转化：将 const 标签删除

第二种转化：尝试将类型由 const High* 转化为 const Low* 

对比C语言的强制转换，以上两种强转都是允许的，可能会导致编程时无意间改变类型



const_cast 也会有失效的时候：

```cpp
const int a = 10;
int* b = const_cast<int*>(&a);
cout << a << endl;		// 10
cout << *b << endl;		// 10
*b += 2;
cout << *b << endl;		// 12
cout << a << endl;		// 10
```

该种情况下，在编译时，会将所有的使用到a的地方全部替换成10，故会出现失效的情况发生



# static_cast

规则：`static_cast <type-name> (expression)`

功能：继承关系中`向上转型`和`向下转型`，还有各种`内置数据类型`之间的相互转换

```cpp
// 向下转型
High* ph = new High();
Low* pl = static_cast<Low *>(ph);

// 向上转型
Low* pl = new Low();
High* ph = static_cast<High *>(pl);

// 内置类型
double d = 19.775;
int a = static_cast<int> (d);
cout << a << endl;	// 19
```



# reinterpret_cast

规则：`reinterpret_cast <type-name> (expression)`

功能：：interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值

```cpp
long a = 0x00100010;
// 将4个字节的a变成两个2字节的变量
data* da = reinterpret_cast<data*>(&a);
cout << da->c << endl;	// 16	
cout << da->d << endl;	// 16
```

这种转换是不可移植的，例如，不同系统在存储多字节整数时，可能以不同的顺序存储其中的字节，所以使用该转换时需要当心~