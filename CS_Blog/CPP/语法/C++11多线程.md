# 1. cpp11线程库简介

> cpp11提供了一个用于多线程编程的库 thread ，使用该库编写的多线程程序，既可以在Linux上运行，也可以在WIndows中运行，具有良好的可移植性

```cpp
#include <thread>
thread();
template<class _Fn,class... _Args>
	thread(_Fn&& _Fx, _Args&&... _Ax);
void join();
void swap(thread& _Other);
bool joinable();
void detach();
id get_id();

// vs下查看id是个啥
typedef struct
{ /* thread identifier for Win32 */
 void *_Hnd; /* Win32 HANDLE */
 unsigned int _Id;
} _Thrd_imp_t;
typedef _Thrd_imp_t _Thrd_t;
class thread::id{	// thread id
private:
	_Thrd_t _Thr;
}
```

* 无参构造函数：只创建出来一个线程对象，并没有在内核中开辟一个新线程
* 有参构造函数：传递函数指针进去，并通过后面的不定参数列表给函数传参，创建一个线程对象并关联内核中开辟的新线程，该对象管理线程资源
* `join`：主线程阻塞等待目标线程，目标线程执行结束后，主线程回收其资源后，主线程才能继续运行
* `swap`：交换两个线程对象
* `joinable`：判断线程是否还在运行中
* `detach`：将目标线程分离，线程对象无法管理此线程，主线程无需等待该线程，将该线程的资源释放权利移交给系统
* `get_id`：获取线程ID



thread类是防止拷贝的，即不允许拷贝构造和赋值

```cpp
thread(const thread&) = delete;
thread& operator=(const thread&) = delete;
```

但是，允许`移动赋值`和`移动拷贝`，即线程对象关联线程的状态转移给其他线程对象，这是一种`管理线程资源的权限`转移

```cpp
thread(thread&& _Other);	// 移动拷贝
thread& operator=(thread&& _Other);	// 移动赋值
```



# 2. 创建线程的几种方式

* 无参构造线程对象：只是产生一个线程对象，并没有在内核中产生一个新的线程
* 有参构造线程对象：将需要执行的函数传递给线程对象，线程对象与内核中的一个新线程关联起来，并管理该线程，让其执行函数
  * 函数指针传递参数
  * Lambda表达式传递参数
  * 仿函数传递参数

```cpp
#include <iostream>
#include <thread>
using namespace std;

void fun(int a)
{
	cout << "function pointer : " << a <<endl;
}

struct MyCop
{
	void operator()(int a)
	{
		cout << "仿函数 : "<< a << endl;
	}
};

int main()
{
	// 无参构造函数
	thread t1;
	cout << t1.get_id() << endl;

	// Lambda表达式传递函数
	thread t2([](int a){
		cout << "lambda expression : " << a << endl;
	}, 10);
	t2.join();

	// 仿函数传递函数
	MyCop mc;
	thread t3(mc, 1);
	t3.join();

	// 函数指针传递函数
	thread t4(fun, 1);
	t4.join();

	return 0;
}
```

