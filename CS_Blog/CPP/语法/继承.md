# 1. 继承的概念及定义

## 1.1 继承的概念

* 继承（inheritance）机制是面向对象程序设计使代码可以复用的重要手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的新类称为派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。

## 1.2 继承的定义

**【定义格式】**

Person是父类，也称作基类。

Student是子类，也称作派生类。

![image-20210214100110505](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214100117.png)



**【继承关系与访问限定符】**

![image-20210214100400801](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214100400.png)



**【不同继承方式下的成员访问属性】**

![image-20210214100615389](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214100615.png)



# 2. 父子类间赋值转换

```cpp
class Person{
protected:
	string _name ; 
	int _age ;
};

class Student : public Person{
public:
	int _id;
};
```

## 2.1 父类指针 指向 子类对象

```cpp
Student sobj;

Person pobj = sobj;		// 子类对象 赋值给 父类对象
Person* pp = &sobj;		// 子类对象 赋值给 父类指针
Person& rp = sobj;		// 子类对象 赋值给 父类引用
```

## 2.2 父类指针 强转赋值给 子类指针

```cpp
Student* ps1 = (Student*)new Person();	// 访问可能会越界
```

## 3.2 父类对象 不能赋值给 子类

```cpp
Student sobj;
Person pobj = sobj;

sobj = pobj;
```

# 4. 子类的默认含有的成员函数

![image-20210214154553258](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214154553.png)

# 5.  菱形继承

## 5.1 菱形继承的概念

**【单继承】**：一个子类只有一个直接父类时，称这个继承关系为单继承

![image-20210214161724052](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214161724.png)

**【多继承】**：一个子类有两个或以上直接父类时，称这个继承关系为多继承

![image-20210214161732626](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214161732.png)

**【菱形继承】**：菱形继承是多继承的一种特殊情况

![image-20210214162152416](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214162152.png)

​	



## 5.2 菱形继承的问题

* 菱形继承的问题：从下面的成员模型可以看出**菱形继承**有**数据冗余**和**二义性**的问题

> **数据冗余**：Assistant类中将\_name和\_num保存了两份
>
> **二义性**：由于\_name保存了两份，Assistant类的\_name就无法被唯一确定

![image-20210214163640376](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214163640.png)

## 5.3 解决菱形继承问题的方法--->虚拟继承

> 使用作用域运算符可以解决菱形继承中数据二义性的问题，但是无法解决数据冗余的问题

```cpp
Assistant a;

// 这样会有二义性无法明确知道访问的是哪一个
a._name = "peter";

// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决
a.Student::_name = "xxx";
a.Teacher::_name = "yyy";
```

> 使用 `虚拟继承` 既可以解决数据二义性问题，也可以解决数据冗余问题

```cpp
class A
{
public:
	int _a;
};

// class B : public A
class B : virtual public A
{
public:
	int _b;
};

// class C : public A
class C : virtual public A
{
public:
	int _c;
};

class D : public B, public C
{
public:
	int _d;
};

int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;

    cout << "d.B::_a : " << &(d.B::_a) << endl;
	cout << "d.C::_a : " << &(d.C::_a) << endl;
	cout << "d._b    : " << &(d._b) << endl;
	cout << "d._c    : " << &(d._c) << endl;
	cout << "d._d    : " << &(d._d) << endl;
    
	return 0;
}
```

**【虚拟继承数据成员模型】**

![image-20210214172215353](https://raw.githubusercontent.com/gongruiyang/BlogImage/main/img/20210214172215.png)



# 6. 继承总结

1. 使用单继承，避免使用多继承
2. public继承是一种 `is - a` 的关系，代码耦合度高，这种复用称为`白箱复用`
3. 数据成员和类之间是一种 `has - a` 的关系，代码耦合度低，这种复用称为`黑箱复用`
4. 优先使用对象组合，而不是类继承

```cpp
// Car和BMW Car和Benz构成is-a的关系
class Car{};
class BMW : public Car{ };
class Benz : public Car{ };
// Tire和Car构成has-a的关系
class Tire{};
class Car{
protected:
	Tire _t; // 轮胎
};
```

