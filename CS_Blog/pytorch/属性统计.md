# 1. norm - p

```python
def norm(self, p="fro", dim=None, keepdim=False, dtype=None):
```

* 返回

```python
a = torch.ones([1, 1, 1, 1, 1, 1, 1, 1])    # dim = 8
b = torch.ones([2, 2, 2])   # dim = 3
c = torch.ones([8])     # dim = 1

print(a.norm(1))    # tensor(1.)
print(b.norm(1))    # tensor(8.)
print(c.norm(1))    # tensor(8.)

print(a.norm(2))    # tensor(1.)
print(b.norm(2))    # tensor(2.8284)
print(c.norm(2))    # tensor(2.8284)

print(a.norm(1, dim=0))    # tensor([[[[[[[1.]]]]]]])
print(b.norm(1, dim=0))    # tensor([[2., 2.],[2., 2.]])
print(c.norm(1, dim=0))    # tensor(8.)
```



# 2. mean sum min max prod 

* min：最小值
* max：最大值
* sum：求和
* mean：平均值
* prod：累乘

```python
a = torch.arange(8).view(2, 4).float()
print(a)    # tensor([[0., 1., 2., 3.], [4., 5., 6., 7.]])

print(a.min()) # tensor(0.)
print(a.max()) # tensor(7.)
print(a.mean()) # tensor(3.5000)
print(a.prod()) # tensor(0.)
```

# 3. argmin argmax

* argmin：返回最小值的下标
* argmax：返回最大值的下标

```python
a = torch.arange(8).view(2, 4).float()
print(a)    # tensor([[0., 1., 2., 3.], [4., 5., 6., 7.]])

print(a.argmin())   # tensor(0)
print(a.argmax())   # tensor(7)
```

# 4. Top - k or k - th

## 4.1 top k

```python
def topk(k, dim=None, largest=True, sorted=True) -> (Tensor, LongTensor)
```

* 如果不指定 dim 维度，则返回所有维度中最大的 k 个值
* 如果指定 dim 维度，则返回该 dim 维度中最大的 k 个值
* largest 为 True 时，表示输出 k 个最大值；largest为 False 时，表示输出 k 个最小值

```python
a = torch.arange(8).view(2, 4).float()
print(a)    # tensor([[0., 1., 2., 3.], [4., 5., 6., 7.]])

print(a.topk(2))
'''
torch.return_types.topk(
    values=tensor ([[3., 2.], [7., 6.]]),
    indices=tensor([[3, 2], [3, 2]]))
'''


```



## 4.2 kthvalue

```python
kthvalue(k, dim=None, keepdim=False) -> (Tensor, LongTensor)
```

* 返回每个维度中第 k 小的值及位置
* keepdim 会保持维度

```python
a = torch.arange(8).view(2, 4).float()
print(a)    # tensor([[0., 1., 2., 3.], [4., 5., 6., 7.]])

print(a.kthvalue(2))
'''
torch.return_types.kthvalue(
values=tensor([1., 5.]),
indices=tensor([1, 1]))
'''
```



# 5. compare

> 比较符号：>，>=， <， <=， !=， ==
>
> 比较函数：eq函数 、equal函数

* 比较的返回值是 ByteTensor ，不再是 FloatTensor 。
* 满足的位置为True，不满足的位置为False。

```python
a = torch.rand([4, 4])
print(a)
'''
tensor([[0.0389, 0.8826, 0.2379, 0.2799],
        [0.4425, 0.3308, 0.3622, 0.2456],
        [0.4767, 0.1754, 0.1747, 0.8575],
        [0.0547, 0.7906, 0.9365, 0.2480]])
'''
print(a > 0.5)
'''
tensor([[False,  True, False, False],
        [False, False, False, False],
        [False, False, False,  True],
        [False,  True,  True, False]])
'''
print(a < 0.5)
'''
tensor([[ True, False,  True,  True],
        [ True,  True,  True,  True],
        [ True,  True,  True, False],
        [ True, False, False,  True]])
'''
print(a == 0.5)
'''
tensor([[False, False, False, False],
        [False, False, False, False],
        [False, False, False, False],
        [False, False, False, False]])
'''
print(a != 0.5)
'''
tensor([[True, True, True, True],
        [True, True, True, True],
        [True, True, True, True],
        [True, True, True, True]])
'''
```

`eq函数`

```python
def eq(Tensor1,Tensor2) -> Tensor
```

* 逐个元素进行比较是否相等，不相等返回的Tensor对应位置置为False，相等对应位置置为True

```python
a = torch.ones(2, 3)
b = torch.zeros(2, 3)
print(torch.eq(a, a))   # tensor([[True, True, True],[True, True, True]])
print(torch.eq(a, b))   # tensor([[False, False, False],[False, False, False]])
```



`equal函数`

* 一模一样返回True
* 非一模一样返回False

```python
a = torch.ones(2, 3)
b = torch.zeros(2, 3)
print(torch.equal(a, a))    # True
print(torch.equal(a, b))    # False
```

